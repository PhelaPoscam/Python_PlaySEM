<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Super Controller</title>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #f7f7f9;
            color: #111827;
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px; 
            margin: 0 auto; 
            background: #ffffff;
            border-radius: 8px;
            box-shadow: 0 4px 16px rgba(0,0,0,0.06);
            overflow: hidden;
        }
        
        .header {
            background: #f5f6f8;
            color: #111827;
            padding: 24px 30px;
            text-align: left;
            border-bottom: 1px solid #e5e7eb;
        }
        
        .header h1 {
            font-size: 1.6em;
            margin-bottom: 4px;
            font-weight: 600;
        }
        
        .content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            padding: 30px;
        }
        
        .panel { background: #ffffff; border-radius: 8px; padding: 20px; border: 1px solid #e5e7eb; }
        
        .panel h2 {
            color: #111827;
            margin-bottom: 16px;
            font-size: 1.1em;
            font-weight: 600;
            border-bottom: 1px solid #e5e7eb;
            padding-bottom: 8px;
        }
        
        .form-group { 
            margin-bottom: 15px; 
        }
        
        label {
            display: block; 
            margin-bottom: 5px; 
            font-weight: 600;
            color: #111827;
        }
        
        input, select { 
            width: 100%; 
            padding: 10px; 
            border: 1px solid #d1d5db;
            border-radius: 6px;
            font-size: 14px;
            transition: border-color 0.2s, box-shadow 0.2s;
            background: #ffffff;
            color: #111827;
        }
        
        input:focus, select:focus {
            outline: none;
            border-color: #111827;
            box-shadow: 0 0 0 3px rgba(17,24,39,0.08);
        }
        
        button { 
            padding: 12px 24px; 
            cursor: pointer;
            background: #111827;
            color: #ffffff;
            border: 1px solid #111827;
            border-radius: 6px;
            font-weight: 600;
            font-size: 14px;
            transition: background 0.15s, color 0.15s, border-color 0.15s;
            width: 100%;
        }
        
        button:hover {
            background: #1f2937;
            border-color: #1f2937;
        }
        
        button:active {
            background: #374151;
            border-color: #374151;
        }
        
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }
        
        .status-bar { background: #fafafa; padding: 12px 24px; border-bottom: 1px solid #e5e7eb; display: flex; justify-content: space-between; align-items: center; }
        
        .status-indicator {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .status-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #b91c1c;
            animation: pulse 2s infinite;
        }
        
        .status-dot.connected {
            background: #0f766e;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        .effect-history { max-height: 300px; overflow-y: auto; background: #ffffff; border-radius: 6px; padding: 10px; border: 1px solid #e5e7eb; }
        
        .effect-item { padding: 10px; margin-bottom: 8px; background: #f9fafb; border-left: 4px solid #9ca3af; border-radius: 4px; font-size: 13px; animation: slideIn 0.2s ease-out; }
        
        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateX(-20px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }
        
        .effect-item .time {
            color: #999;
            font-size: 11px;
        }
        
        .effect-item .details {
            margin-top: 5px;
            color: #666;
        }
        
        .device-list { display: grid; gap: 10px; max-height: 200px; overflow-y: auto; background: #fafafa; padding: 10px; border-radius: 8px; border: 1px solid #e5e7eb; }
        
        .device-card { background: #ffffff; padding: 12px; border-radius: 6px; border: 1px solid #d1d5db; cursor: pointer; transition: border-color 0.15s, background 0.15s; }
        
        .device-card:hover { border-color: #111827; }
        
        .device-card.selected { border-color: #111827; background: #f3f4f6; }
        
        .device-card .name { font-weight: 600; color: #111827; }
        
        .device-card .id { font-size: 12px; color: #6b7280; }
        
        .device-card .type { display: inline-block; color: #111827; border: 1px solid #d1d5db; padding: 1px 6px; border-radius: 10px; font-size: 11px; margin-top: 5px; text-transform: uppercase; background: #fff; }
        
        .visual-feedback {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0);
            width: 200px;
            height: 200px;
            border-radius: 50%;
            pointer-events: none;
            z-index: 1000;
            transition: transform 0.3s ease-out, opacity 0.3s;
            opacity: 0;
        }
        
        .visual-feedback.active {
            transform: translate(-50%, -50%) scale(1);
            opacity: 0.7;
        }
        
        .stats {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-top: 15px;
        }
        
        .stat-card { background: #ffffff; padding: 15px; border-radius: 6px; text-align: center; border: 1px solid #e5e7eb; }
        
        .stat-card .value { font-size: 24px; font-weight: 700; color: #111827; }
        
        .stat-card .label {
            font-size: 12px;
            color: #999;
            margin-top: 5px;
        }
        
        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            background: transparent;
        }
        
        input[type="range"]::-webkit-slider-track {
            background: #e0e0e0;
            height: 8px;
            border-radius: 4px;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #6b7280;
            cursor: pointer;
            margin-top: -6px;
        }
        
        input[type="range"]::-moz-range-track {
            background: #e0e0e0;
            height: 8px;
            border-radius: 4px;
        }
        
        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #6b7280;
            cursor: pointer;
            border: none;
        }
        
        .range-value { display: inline-block; background: #e5e7eb; color: #111827; padding: 2px 10px; border-radius: 12px; font-size: 12px; font-weight: 600; margin-left: 10px; }
        
        @media (max-width: 768px) {
            .content {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="visual-feedback" id="visualFeedback"></div>
    
    <div class="container">
        <div class="header">
            <h1>Super Controller</h1>
            <p style="color:#6b7280">Sensory Effect Control Panel</p>
        </div>
        
        <div class="status-bar">
            <div class="status-indicator">
                <div class="status-dot" id="connectionDot"></div>
                <span id="connectionStatus">Connecting...</span>
            </div>
            <div class="status-indicator">
                <span id="deviceCount">0 devices</span>
            </div>
        </div>
        
        <div class="content" style="grid-template-columns: 1fr;">
            <!-- Unified Control Panel -->
            <div class="panel">
                <h2>Device & Effect Control</h2>
                <div class="form-group">
                    <label>Connected Devices</label>
                    <button style="float: right; padding: 4px 12px; font-size: 0.85em;" id="scanSerial">üîç Scan Serial</button>
                    <div class="device-list" id="deviceList">
                        <div style="text-align: center; color: #999; padding: 20px;">No devices connected</div>
                    </div>
                </div>
                <div class="form-group" style="margin-top:10px;">
                    <label for="modality">Effect Type</label>
                    <select id="modality">
                        <option value="light">üí° Light</option>
                        <option value="vibration">üì≥ Vibration</option>
                        <option value="wind">üí® Wind</option>
                        <option value="scent">üå∏ Scent</option>
                        <option value="heat">üî• Heat</option>
                        <option value="cold">‚ùÑÔ∏è Cold</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="intensity">Intensity <span class="range-value" id="intensityValue">50</span></label>
                    <input type="range" id="intensity" min="0" max="100" value="50">
                </div>
                <div class="form-group">
                    <label for="duration">Duration (ms) <span class="range-value" id="durationValue">500</span></label>
                    <input type="range" id="duration" min="100" max="5000" step="100" value="500">
                </div>
                <div class="form-group">
                    <label for="protocol">Protocol</label>
                    <select id="protocol">
                        <option value="websocket">üîå WebSocket</option>
                        <option value="http">üåê HTTP</option>
                        <option value="mqtt">üì° MQTT</option>
                        <option value="coap">üì∂ CoAP</option>
                        <option value="upnp">üîç UPnP</option>
                    </select>
                </div>
                <div class="form-group" id="deviceEffectWrapper" style="display:none;">
                    <label for="capEffectType">Device Capability Effect</label>
                    <select id="capEffectType">
                        <option value="">‚Äî Select Device First ‚Äî</option>
                    </select>
                </div>
                <div id="capParams" style="margin-top:10px;"></div>
                <div style="display:grid; grid-template-columns:1fr 1fr; gap:10px; margin-top:15px;">
                    <button id="sendEffect">üöÄ Send to All via Protocol</button>
                    <span id="sendEffectTarget" style="font-size: 0.85em; color: #777; align-self: center; margin-left: 10px;"></span>
                </div>
                
                <hr style="margin: 20px 0; border: 0; border-top: 1px solid #eee;">

                <div class="form-group">
                    <p style="font-size: 0.9em; color: #555; margin-bottom: 5px;">
                        Protocol for Selected Device: <strong id="selectedDeviceProtocol">N/A</strong>
                    </p>
                    <button id="sendCapEffect" disabled>üì§ Send to Selected</button>
                </div>
                <div class="stats" style="margin-top:20px;">
                    <div class="stat-card"><div class="value" id="totalSent">0</div><div class="label">Sent</div></div>
                    <div class="stat-card"><div class="value" id="successRate">100%</div><div class="label">Success</div></div>
                    <div class="stat-card"><div class="value" id="avgLatency">0ms</div><div class="label">Latency</div></div>
                </div>
            </div>
            <div class="panel" style="margin-top:20px;">
                <h2>Effect History</h2>
                <div class="effect-history" id="effectHistory">
                    <div style="text-align: center; color: #999; padding: 20px;">No effects sent yet</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // State management
        let connectedDevices = [];
        let selectedDeviceId = null;
        let latestCaps = null;
        let effectHistory = [];
        let stats = { sent: 0, success: 0, totalLatency: 0 };
        
        // DOM elements
        const connectionDot = document.getElementById('connectionDot');
        const connectionStatus = document.getElementById('connectionStatus');
        const deviceCount = document.getElementById('deviceCount');
        const deviceList = document.getElementById('deviceList');
        const effectHistoryDiv = document.getElementById('effectHistory');
        const visualFeedback = document.getElementById('visualFeedback');
        const sendButton = document.getElementById('sendEffect');
        const capEffectType = document.getElementById('capEffectType');
        const capParams = document.getElementById('capParams');
        const sendCapEffectBtn = document.getElementById('sendCapEffect');
        const selectedDeviceProtocolSpan = document.getElementById('selectedDeviceProtocol');
        const sendEffectTargetSpan = document.getElementById('sendEffectTarget');
        
        // Stats elements
        const totalSent = document.getElementById('totalSent');
        const successRate = document.getElementById('successRate');
        const avgLatency = document.getElementById('avgLatency');
        
        // Range value displays
        const intensityInput = document.getElementById('intensity');
        const durationInput = document.getElementById('duration');
        const intensityValue = document.getElementById('intensityValue');
        const durationValue = document.getElementById('durationValue');
        
        // WebSocket connection
        const ws = new WebSocket(`ws://${window.location.host}/ws`);
        
        // Update range value displays
        intensityInput.addEventListener('input', () => {
            intensityValue.textContent = intensityInput.value;
        });
        
        durationInput.addEventListener('input', () => {
            durationValue.textContent = durationInput.value;
        });

        // Update send effect target text
        const protocolSelect = document.getElementById('protocol');
        function updateSendEffectTarget() {
            const selectedProtocol = protocolSelect.value;
            let targetText = "";
            switch (selectedProtocol) {
                case "websocket":
                    targetText = "Targets all connected web clients.";
                    break;
                case "http":
                    targetText = "Targets HTTP server (port 8081).";
                    break;
                case "mqtt":
                    targetText = "Targets MQTT broker (topic effects/sem).";
                    break;
                case "coap":
                    targetText = "Targets CoAP server (port 5683).";
                    break;
                case "upnp":
                    targetText = "Targets UPnP server.";
                    break;
                default:
                    targetText = "";
            }
            sendEffectTargetSpan.textContent = targetText;
        }

        protocolSelect.addEventListener('change', updateSendEffectTarget);
        
        // WebSocket handlers
        ws.onopen = () => {
            updateConnectionStatus(true);
            ws.send(JSON.stringify({ type: 'get_devices' }));
            updateSendEffectTarget(); // Initial update
        };
        
        ws.onmessage = (event) => {
            try {
                const msg = JSON.parse(event.data);
                
                if (msg.type === 'device_list') {
                    connectedDevices = msg.devices || [];
                    updateDeviceList();
                    return;
                }
                
                if (msg.type === 'effect_ack') {
                    stats.success++;
                    updateStats();
                    addToHistory('Effect acknowledged', 'success', msg);
                    return;
                }
                
                if (msg.type === 'effect_protocol_result') {
                    if (msg.success) {
                        stats.success++;
                        const effectDetails = {
                            type: msg.effect_type,
                            protocol: msg.protocol,
                            intensity: msg.intensity,
                            duration: msg.duration
                        };
                        addToHistory(`‚úÖ Effect sent via ${msg.protocol?.toUpperCase()}`, 'success', effectDetails);
                    } else {
                        addToHistory(`‚ùå ${msg.protocol?.toUpperCase()} Error: ${msg.error}`, 'error');
                        alert(`Protocol Error!\n\n${msg.protocol?.toUpperCase()}: ${msg.error}\n\nThis may be due to:\n- Protocol server not started\n- Python 3.14 httpx compatibility issue\n- Missing dependencies`);
                    }
                    updateStats();
                    return;
                }
                
                if (msg.type === 'error') {
                    addToHistory(`‚ùå Error: ${msg.message}`, 'error');
                    return;
                }
                
                if (msg.type === 'device_discovered') {
                    const dev = msg.device || {};
                    const deviceInfo = `${dev.name} (${dev.address}) - ${dev.type}`;
                    addToHistory(`üîç Found: ${deviceInfo}`, 'info');
                    return;
                }
                
                if (msg.type === 'effect_result') {
                    if (msg.success) {
                        stats.success++;
                        addToHistory(`‚úÖ Effect sent to device (${msg.latency}ms)`, 'success');
                    } else {
                        addToHistory(`‚ùå Device Error: ${msg.error}`, 'error');
                    }
                    updateStats();
                    return;
                }
                
                addToHistory('Server message', 'info', msg);
                
            } catch(e) {
                console.error('Error parsing message:', e);
            }
        };
        
        ws.onclose = () => {
            updateConnectionStatus(false);
            setTimeout(() => {
                console.log('Reconnecting...');
                window.location.reload();
            }, 5000);
        };
        
        ws.onerror = (error) => {
            console.error('WebSocket error:', error);
            updateConnectionStatus(false);
        };
        
        // Serial device scanning
        document.getElementById('scanSerial').addEventListener('click', () => {
            addToHistory('Scanning for serial devices...', 'info');
            ws.send(JSON.stringify({
                type: 'scan_devices',
                driver_type: 'serial'
            }));
        });
        
        // Connection status
        function updateConnectionStatus(connected) {
            if (connected) {
                connectionDot.classList.add('connected');
                connectionStatus.textContent = 'Connected';
            } else {
                connectionDot.classList.remove('connected');
                connectionStatus.textContent = 'Disconnected';
            }
        }
        
        // Device list management
        function updateDeviceList() {
            deviceCount.textContent = `${connectedDevices.length} device${connectedDevices.length !== 1 ? 's' : ''}`;
            
            if (connectedDevices.length === 0) {
                deviceList.innerHTML = '<div style="text-align: center; color: #999; padding: 20px;">No devices connected</div>';
                sendCapEffectBtn.disabled = true;
                return;
            }
            
            deviceList.innerHTML = '';
            connectedDevices.forEach(device => {
                const card = document.createElement('div');
                card.className = 'device-card';
                if (device.id === selectedDeviceId) {
                    card.classList.add('selected');
                }
                
                // Show protocols if available
                const protocols = device.protocols || [];
                const protocolBadges = protocols.length > 0 
                    ? `<div style="margin-top: 8px; display: flex; gap: 4px; flex-wrap: wrap;">
                        ${protocols.map(p => `<span style="background: rgba(102, 126, 234, 0.3); padding: 2px 8px; border-radius: 10px; font-size: 0.75em; text-transform: uppercase;">${p}</span>`).join('')}
                       </div>`
                    : '';
                
                // Show capabilities if available
                const capabilities = device.capabilities || [];
                const capBadges = capabilities.length > 0
                    ? `<div style="margin-top: 4px; font-size: 0.8em; color: #999;">
                        ${capabilities.map(c => getEffectIcon(c)).join(' ')}
                       </div>`
                    : '';
                
                // Show connection mode
                const connectionMode = device.connection_mode || 'direct';
                const modeIcon = connectionMode === 'isolated' ? 'üîí' : 'üîÄ';
                const modeBadge = `<div style="margin-top: 4px; font-size: 0.7em; color: ${connectionMode === 'isolated' ? '#ff9800' : '#4caf50'};">
                    ${modeIcon} ${connectionMode.toUpperCase()}
                </div>`;
                
                card.innerHTML = `
                    <div class="name">${device.name || device.id}</div>
                    <div class="id">${device.id}</div>
                    <span class="type">${device.type || 'unknown'}</span>
                    ${modeBadge}
                    ${protocolBadges}
                    ${capBadges}
                `;
                
                card.onclick = () => selectDevice(device.id);
                deviceList.appendChild(card);
            });
        }
        
        // Device selection
        async function selectDevice(deviceId) {
            selectedDeviceId = deviceId;
            updateDeviceList();
            
            if (!selectedDeviceId) {
                selectedDeviceProtocolSpan.textContent = 'N/A';
                sendCapEffectBtn.disabled = true;
                populateCapabilityUI(null); // Clear capabilities
                return;
            }

            const selectedDevice = connectedDevices.find(d => d.id === selectedDeviceId);
            const protocolForSelected = (selectedDevice && selectedDevice.protocols && selectedDevice.protocols.length > 0)
                                        ? selectedDevice.protocols[0]
                                        : 'websocket';
            selectedDeviceProtocolSpan.textContent = protocolForSelected.toUpperCase();
            
            // Fetch capabilities
            try {
                const res = await fetch(`/api/capabilities/${encodeURIComponent(deviceId)}`);
                const caps = await res.json();
                latestCaps = caps;
                populateCapabilityUI(caps);
                sendCapEffectBtn.disabled = false;
                addToHistory(`Device selected: ${deviceId} (Protocol: ${protocolForSelected.toUpperCase()})`, 'info');
            } catch (e) {
                console.error('Failed to fetch capabilities:', e);
                addToHistory(`Failed to fetch capabilities for ${deviceId}`, 'error');
                sendCapEffectBtn.disabled = true;
                populateCapabilityUI(null); // Clear capabilities on error
            }
        }
        
        // Capability UI
        function populateCapabilityUI(caps) {
            const effects = (caps && caps.effects) || [];
            capEffectType.innerHTML = '';
            
            if (effects.length === 0) {
                capEffectType.innerHTML = '<option value="">No effects available</option>';
                return;
            }
            
            effects.forEach(e => {
                const opt = document.createElement('option');
                opt.value = e.effect_type;
                opt.textContent = `${getEffectIcon(e.effect_type)} ${e.effect_type}`;
                capEffectType.appendChild(opt);
            });
            
            renderParamsForSelectedEffect();
            capEffectType.onchange = renderParamsForSelectedEffect;
        }
        
        function renderParamsForSelectedEffect() {
            const effect = (latestCaps?.effects || []).find(e => e.effect_type === capEffectType.value) || null;
            capParams.innerHTML = '';
            
            if (!effect) return;
            
            (effect.parameters || []).forEach(p => {
                // Skip intensity and duration as they're handled separately
                if (p.name === 'intensity' || p.name === 'duration') return;
                
                const wrapper = document.createElement('div');
                wrapper.className = 'form-group';
                const label = document.createElement('label');
                const suffix = p.unit ? ` (${p.unit})` : (p.format ? ` (${p.format})` : '');
                const rangeHint = (p.min != null || p.max != null) ? ` [${p.min ?? ''}..${p.max ?? ''}]` : '';
                label.textContent = `${p.name}${suffix}${rangeHint}`;
                
                let input;
                let valueDisplay;
                
                if (p.type === 'int' || p.type === 'float') {
                    valueDisplay = document.createElement('span');
                    valueDisplay.className = 'range-value';
                    valueDisplay.textContent = p.default ?? p.min ?? 0;
                    label.appendChild(valueDisplay);
                    
                    input = document.createElement('input');
                    input.type = 'range';
                    input.min = p.min ?? 0;
                    input.max = p.max ?? (p.type === 'int' ? 255 : 1.0);
                    input.step = p.type === 'int' ? 1 : (p.step ?? 0.01);
                    input.value = p.default ?? input.min;
                    
                    input.addEventListener('input', () => {
                        valueDisplay.textContent = input.value;
                    });
                } else if (p.type === 'string' && (p.format === '#RRGGBB' || p.format === 'color')) {
                    input = document.createElement('input');
                    input.type = 'color';
                    input.value = p.default || '#ffffff';
                } else if (p.enum) {
                    input = document.createElement('select');
                    (p.enum || []).forEach(val => {
                        const o = document.createElement('option');
                        o.value = val;
                        o.textContent = val;
                        input.appendChild(o);
                    });
                } else {
                    input = document.createElement('input');
                    input.type = 'text';
                    input.value = p.default || '';
                }
                
                input.name = p.name;
                wrapper.appendChild(label);
                wrapper.appendChild(input);
                capParams.appendChild(wrapper);
            });
        }
        
        // Quick send effect
        sendButton.addEventListener('click', () => {
            const startTime = Date.now();
            const protocol = document.getElementById('protocol').value;
            const modality = document.getElementById('modality').value;
            const intensity = parseInt(intensityInput.value);
            const duration = parseInt(durationInput.value);
            
            const msg = {
                type: 'send_effect_protocol',
                protocol: protocol,
                effect: {
                    effect_type: modality,
                    intensity: intensity,
                    duration: duration
                }
            };
            
            ws.send(JSON.stringify(msg));
            
            // Update stats
            stats.sent++;
            stats.totalLatency += Date.now() - startTime;
            updateStats();
            
            // Visual feedback
            showVisualFeedback(modality, intensity);
            
            // Add to history
            addToHistory(`Sent ${modality} effect`, 'sent', {
                intensity, duration, protocol
            });
        });
        
        // Send effect from capabilities
        sendCapEffectBtn.addEventListener('click', () => {
            if (!selectedDeviceId) {
                addToHistory('No device selected', 'error');
                return;
            }

            const selectedDevice = connectedDevices.find(d => d.id === selectedDeviceId);
            if (!selectedDevice) {
                addToHistory('Could not find selected device details.', 'error');
                return;
            }

            // Determine the protocol. Use the device's first protocol, or fallback to websocket.
            const protocol = (selectedDevice.protocols && selectedDevice.protocols.length > 0)
                             ? selectedDevice.protocols[0]
                             : 'websocket';
            
            const startTime = Date.now();
            const effect_type = capEffectType.value || 'vibration';
            const params = {};
            const inputs = capParams.querySelectorAll('input, select');
            inputs.forEach(el => { params[el.name] = el.value; });
            
            const intensity = parseInt(params.intensity ?? 50);
            const duration = parseInt(params.duration ?? 1000);
            delete params.intensity;
            delete params.duration;
            
            const msg = {
                type: 'send_effect',
                device_id: selectedDeviceId,
                protocol: protocol,
                effect: { effect_type, intensity, duration, parameters: params }
            };
            
            ws.send(JSON.stringify(msg));
            
            // Update stats
            stats.sent++;
            stats.totalLatency += Date.now() - startTime;
            updateStats();
            
            // Visual feedback
            showVisualFeedback(effect_type, intensity);
            
            // Add to history
            addToHistory(`Sent ${effect_type} to ${selectedDeviceId} via ${protocol}`, 'sent', {
                intensity, duration, params, protocol
            });
        });
        
        // Visual feedback
        function showVisualFeedback(effectType, intensity) {
            const colors = {
                light: '#FFC107',
                vibration: '#FF5722',
                wind: '#03A9F4',
                scent: '#9C27B0'
            };
            
            visualFeedback.style.background = colors[effectType] || '#667eea';
            visualFeedback.style.opacity = intensity / 100;
            visualFeedback.classList.add('active');
            
            setTimeout(() => {
                visualFeedback.classList.remove('active');
            }, 300);
        }
        
        // Effect history
        function addToHistory(message, type = 'info', details = null) {
            const time = new Date().toLocaleTimeString();
            
            // Clear "no effects" message
            if (effectHistory.length === 0) {
                effectHistoryDiv.innerHTML = '';
            }
            
            const item = document.createElement('div');
            item.className = 'effect-item';
            
            const borderColors = {
                sent: '#667eea',
                success: '#2ecc71',
                error: '#e74c3c',
                info: '#999'
            };
            item.style.borderLeftColor = borderColors[type] || '#999';
            
            let detailsHtml = '';
            if (details) {
                if (details.type || details.intensity != null || details.duration != null || details.protocol) {
                    let effectInfo = [];
                    if (details.type) effectInfo.push(`Type: ${getEffectIcon(details.type)} ${details.type}`);
                    if (details.protocol) effectInfo.push(`Protocol: ${details.protocol.toUpperCase()}`);
                    if (details.intensity != null) effectInfo.push(`Intensity: ${details.intensity}`);
                    if (details.duration != null) effectInfo.push(`Duration: ${details.duration}ms`);
                    
                    detailsHtml = `<div class="details">${effectInfo.join(' | ')}</div>`;
                } else if (Object.keys(details).length > 0) {
                    // Fallback for other arbitrary details
                    detailsHtml = `<div class="details">${JSON.stringify(details, null, 2)}</div>`;
                }
            }
            
            item.innerHTML = `
                <div><strong>${message}</strong></div>
                <div class="time">${time}</div>
                ${detailsHtml}
            `;
            
            effectHistoryDiv.insertBefore(item, effectHistoryDiv.firstChild);
            effectHistory.push({ time, message, type, details });
            
            // Keep only last 50 items
            if (effectHistory.length > 50) {
                effectHistoryDiv.removeChild(effectHistoryDiv.lastChild);
                effectHistory.shift();
            }
        }
        
        // Update stats
        function updateStats() {
            totalSent.textContent = stats.sent;
            const rate = stats.sent > 0 ? Math.round((stats.success / stats.sent) * 100) : 100;
            successRate.textContent = `${rate}%`;
            const avgLat = stats.sent > 0 ? Math.round(stats.totalLatency / stats.sent) : 0;
            avgLatency.textContent = `${avgLat}ms`;
        }
        
        // Helper functions
        function getEffectIcon(effectType) {
            const icons = {
                light: 'üí°',
                vibration: 'üì≥',
                wind: 'üí®',
                scent: 'üå∏',
                heat: 'üî•',
                cold: '‚ùÑÔ∏è'
            };
            return icons[effectType] || '‚ö°';
        }
        
        // Initialize
        console.log('Super Controller initialized');
    </script>
</body>
</html>
